---
title: LeetCode 2801. 统计范围内的步进数字数目
date: 2023-07-31
tags: [dp, 算法, 数位dp]
---

---
## dp

```python
# 灵神
class Solution:
    def countSteppingNumbers(self, low: str, high: str) -> int:
        MOD = 10 ** 9 + 7
        def calc(s: str) -> int:
            @cache  # 记忆化搜索
            def f(i: int, pre: int, is_limit: bool, is_num: bool) -> int:
                if i == len(s):
                    return int(is_num)  # is_num 为 True 表示得到了一个合法数字
                res = 0
                if not is_num:  # 可以跳过当前数位
                    res = f(i + 1, pre, False, False)
                low = 0 if is_num else 1  # 如果前面没有填数字，必须从 1 开始（因为不能有前导零）
                up = int(s[i]) if is_limit else 9  # 如果前面填的数字都和 n 的一样，那么这一位至多填 s[i]（否则就超过 s 啦）
                for d in range(low, up + 1):  # 枚举要填入的数字 d
                    if not is_num or abs(d - pre) == 1:  # 第一位数字随便填，其余必须相差 1
                        res += f(i + 1, d, is_limit and d == up, True)
                return res % MOD
            return f(0, 0, True, False)
        return (calc(high) - calc(str(int(low) - 1))) % MOD
```
---
```cpp
// bfs + 排序
// 阅读理解
#include <bits/stdc++.h>
using namespace std;

const int N = 2010, M = 2 * N;

int h[N], e[M], ne[M], idx;

struct Air 
{
    int num, flow;    
} p[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

int main()
{
    memset(h, -1, sizeof h);
    int n;
    scanf("%d", &n);
    while (n -- )
    {
        int a, b, c, d;
        scanf("%d%d%d%d", &a, &b, &c, &d);
        if (a >= 100)
        {
            if (d != -1) add(a, d);
            if (c != -1) add(a, c);
            if (b != -1) add(a, b);
        }
    }

    int num, flow, cnt = 0;
    while (scanf("%d%d", &num, &flow) != EOF)
    {
        p[cnt ++ ] = {num, flow};
    }
    sort(p, p + cnt, [&](Air x, Air y) {
        if (x.flow != y.flow) return x.flow > y.flow;
        return x.num < y.num;
    });

    queue<int> q;
    q.push(100);
    cnt = 0;

    while (q.size())
    {
        auto t = q.front();
        q.pop();
        for (int i = h[t]; ~i ; i = ne[i])
        {
            int j = e[i];
            if (j > 100) q.push(j);
            else
            {
                printf("%d %d\n", p[cnt ++ ].num, j);
            }
        }
    }

    return 0;
}
```